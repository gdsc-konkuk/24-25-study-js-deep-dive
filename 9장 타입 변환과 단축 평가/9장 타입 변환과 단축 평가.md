# 9장 타입 변환과 단축 평가
## 9.1 타입 변환이란?
- JS의 모든 값은 타입을 가진다. 개발자가 의도적으로 타입 변환하는 것을 명시적 타입 변환 explicit coercion 또는 타입 캐스팅 Type casting 이라 한다.
- 개발자의 의도와는 상관없이 표현식 평가 도중에 JS 엔진이 암묵적으로 타입을 자동 변환하는 것을 암묵적 타입 변환 implicit coercion 또는 타입 강제 변환 Type coercion 이라 한다.
- 원시 값은 변경 불가능한 값이라 기존 원시 값을 직접 변경하는 것이 아니라, 타입 변환이 일어나면 기본 원시 값을 이용해 다른 타입의 새로운 원시 값을 생성하는 것이다.
	- 즉, 암묵적 타입 변환은 기존 변수에다 값을 재할당해서 변경하는 것이 아니라, 표현식을 평가할 때만 암묵적으로 변환해서 새로운 값으로 사용 후에 이 값은 버린다.
## 9.2 암묵적 타입 변환
### 9.2.1 문자열 타입으로 변환
- `+` 연산자의 피연산자 중 하나 이상이 문자열이라면, 문자열 연결 연산자로 동작한다.
	- 문자열 연결 연산자의 피연산자 중 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.
- 리터럴 표현식은 표현식 결과를 문자열로 암묵적 타입 변환한다.
> Symbol type은 string으로 바꿀 수 없다.
### 9.2.2 숫자 타입으로 변환
- `-`, `*`, `/` 등의 산술 연산자의 피연산자는 모두 숫자 타입으로 암묵적 타입 변환되며, 피연산자를 변환할 수 없는 경우 표현식 평가 결과는 `NaN`이 된다.
- 비교 연산자도 숫자 타입으로 암묵적 타입 변환한다.
### 9.2.3 불리언 타입으로 변환
- 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.
- **자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.**
	- 명시적으로 false 값이 아니더라도 undefined, null, NaN등의 Falsy 값은 false로 평가된다.
> [!question] 관련 퀴즈  
>   
> ```js
> 0 == [] // true
> 0 == "0" // true
> "0" == [] // false
> ```
> - 배열은 number type으로 암시적 변환될 때 0으로 변환되는 반면, string type으로 암시적 변환될 때 "" 빈 문자열로 변환되기 때문에 위와 같은 결과가 나온다.

## 9.3 명시적 타입 변환
- 표준 빌트인 생성자 함수 / 빌트인 메서드 / 암묵적 타입 변환 이용
### 9.3.1 문자열 타입으로 변환
1. `String()` 생성자 함수 호출
2. `Object.prototype.toString` 메서드 이용
3. 문자열 연결 연산자를 통한 암묵적 타입 변환
### 9.3.2 숫자 타입으로 변환
1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
2. parselnt, parseFIoat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가늠)
3. `+` 단항 산술 연산자를 이용하는 방법
4. `*` 산술 연산자를 이용하는 방법
### 9.3.3 불리언 타입으로 변환
1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
2. ! 부정 논리 연산자를 두 번 사용하는 방법
## 9.4 단축 평가 
> react에서 자주 쓰는 단축평가의 자세한 내용!
### 9.4.1 논리 연산자를 사용한 단축 평가
- 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한 쪽으로 평가된다.
```js
'Cat' && 'Dog' // -> "Dog"
'Cat' || 'Dog' // -> "Cat"
```
- 좌항에서 우항으로 평가가 진행되는데, 논리곱의 경우 첫 항이 true인 경우 두 번째 피연산자가 논리곱 연산자 표현식 전체의 평가 결과를 결정한다.
	- 이때 논리곱 연산자는 **논리 연산의 결과를 결정하는 두 번째 피연산자를 그대로 반환**한다.
- 논리합 연산자는 첫 항이 true로 평가되는 경우 두 번째 피연산자까지 확인하지 않아도 전체 표현식은 true이다.
	- 이때 논리합 연산자는 첫 번째 피연산자를 그대로 반환한다.

- **단축 평가**란 **표현식 평가 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략**하는 걸 말한다.
	- 어떤 조건이 Truthy 값일 때 논리곱(&&) 연산자 표현식으로 if 문 대체 가능
	- 어떤 조건이 Falsy 값일 때 논리합(||) 연산자 표현식으로 if 문 대체 가능
 
 > [!info] 객체가 null 또는 undefined가 아닌지 확인하고 객체의 프로퍼티 참조할 때 && 사용
> ```js
> var obj = null;
> var prop = obj.prop; // TypeError: Cannot read property 'prop' of null
> 
> var prop = obj && obj.prop;
> var prop = obj?.prop; //ES11에서 새로 도입된 옵셔널 체이닝 연산자
> ```

> [!info] 함수 매개변수에 기본값을 설정할 때 || 사용
> - 함수 호출 시 인수 전달이 없으면 매개변수에 자동으로 undefined 할당
> - 단축 평가를 통해 매개변수 기본값 설정해서 undefined 방지
> - ES6부터는 매개변수 기본값을 `=` 연산자로 바로 설정 가능
> ```js
> function getStringLength(str) {
>   str = str || '';
>   return str.length;
> }
> getStringLength(); // => 0
> 
> // ES6의 매개변수 기본값 설정 기능
> function getStringLength(str = '') {
> return str.length;
> }
> getStringLength(); // => 0
> ```
### 9.4.2 옵셔널 체이닝 연산자 `?.`
- ES11에서 새로 도입
- 옵셔널 체이닝 연산자 앞의 객체가 null, undefined 라면 오류 대신 undefind 반환
> [!NOTE] `&&` 와 `?.` 의 차이점
> - 논리 연산자 &&는 단축 평가를 통해 좌항이 Falsy 값(false, undefined, null, 0, -0, NaN, '')이면 좌항 피연산자를 그대로 반환한다.
> 	- 단, 0이나 ''은 객체로 평가될 때도 있다. (21.3절 참고)
> - 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy 값이어도 null 또는 undefined가 아니면 우항의 property 참조를 이어간다.
