# 23장 실행 컨텍스트

- 실행 컨텍스트는 JS의 동작 원리를 담은 핵심 개념이다.
- 이를 잘 이해하면 JS가 스코프를 기반으로 식별자와 식별자에 바인딩 된 값을 관리하는 방식, 호이스팅 밠생 이유, 클로저 동작 방식, 테스크 큐와 함께 동작하는 이벤트 핸들러와 비동기 처리 동작 방식을 이해할 수 있다.

## 23.1 소스코드의 타입

- ECMAScript 사양은 ECMAScript Code를 4가지 type으로 구분한다. 4가지 type의 소스코드는 실행 컨텍스트를 생성한다.

| 소스코드의 타입 | 설명                                                                                         |
| --------------- | -------------------------------------------------------------------------------------------- |
| 전역 코드       | 전역에 존재하는 소스코드. 전역에 정의된 함수, 클래스의 내부 코드는 포함하지 않음.            |
| 함수 코드       | 함수 내부에 존재하는 소스코드. 함수 내부 중첩 함수, 중첩 클래스의 내부 코드는 포함하지 않음. |
| eval 코드       | built-in 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드                           |
| 모듈 코드       | 모듈 내부에 존재하는 소스코드. 모듈 내부의 함수, 클래스의 내부 코드는 포함하지 않음.         |

- 소스코드 타입 구분 이유는 각 타입에 따라 실행 컨텍스트 생성 및 관리 과정이 다르기 때문이다.

1. 전역 코드
   - 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프 생성
   - var로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하기 위해 전역 객체와 연결되어야 한다.
   - 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.
2. 함수 코드
   - 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리한다.
   - 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인으로 연결한다.
   - 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.
3. eval 코드
   - strict mode에서 자신만의 독자적 스코프를 생성한다.
   - eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다.
4. 모듈 코드
   - 모듈 코드가 평가되면 모듈별로 독립적인 모듈 스코프를 생성한다.

## 23.2 소스코드의 평가와 실행

- 모든 소스코드는 실행에 앞서 평가 과정을 거친다.
- 소스코드 평가 과정에선 실행 컨텍스트를 생성하고 변수, 함수 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.

- 평가 과정이 끝나면 선언문을 제외한 소스 코드가 순차적으로 실행되며 런타임이 시작된다.
  - 이때 실행에 필요한 정보(변수, 함수)의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다.
  - 만약 변수 값의 변경이 일어나는 경우 다시 스코프에 등록된다.

```js
var x;
x = 1;
```

- 위와 같은 소스코드가 실행될 때, 먼저 소스 코드 평가 과정에서 변수 선언문 `var x;`를 먼저 실행한다.
  - x는 undefined로 초기화되어 실행 컨텍스트 스코프에 등록된다.
  - 평가 과정이 끝났으므로 소스 코드가 실행된다. `x = 1;`이 실행되며 먼저 x 변수가 선언되었는지 실행 컨텍스트 스코프에서 확인한다.
  - x가 선언된 변수라면 값을 할당하고, 그 결과를 다시 스코프에 등록한다.

## 23.3 실행 컨텍스트의 역할

- 전역 코드와 함수 코드로 구성된 아래 예제를 JS 엔진이 어떻게 평가하고 실행하는지 생각해보자.

```js
const x = 1;
const y = 2;

function foo(a) {
  const x = 10;
  const y = 20;

  console.log(a + x + y); // 130
}

foo(100);

console.log(x + y); // 3
```

1. 전역 코드 평가 : 전역 변수와 함수를 전역 스코프에 등록한다.
2. 전역 코드 실행 : 전역 변수에 값을 할당하고 함수가 호출되면 함수 내부로 진입한다.
3. 함수 코드 평가 : 함수 내부에 진입하면 다시 코드를 평가하며, 매개변수와 지역 변수를 지역 스코프에 등록한다.
4. 함수 코드 실행 : 매개변수와 지역 변수에 값이 할당되고 console.log 메서드가 호출된다.
   - console 식별자를 스코프 체인을 통해 검색하는데 이는 스코프 체인에 등록되지 않고 전역 객체의 프로퍼티로 존재한다.
   - 전역 객체의 프로퍼티도 전역 변수처럼 전역 스코프를 통해 검색이 가능해야 한다.
   - log 프로퍼티를 console 객체 프로토타입 체인을 통해 검색한다.
   - a, x, y 식별자는 스코프 체인을 통해 검색한다.

- 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.
  > [!note] 실행 컨텍스트
  >
  > 1. 선언에 의해 생성된 모든 식별자 (변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(바인딩 값 변화)를 지속 관리 가능
  > 2. 스코프는 중첩 관계에 의해 스코프 체인 형성. 상위 스코프로 이동하여 식별자 검색 가능
  > 3. 현재 실행 중인 코드 실행 순서 변경(함수 호출 등)가능해야 하고, 다시 되돌아갈 수 있어야 한다.
- 실행 컨텍스트는 소스 코드를 실행하는데 필요한 환경을 제공하고 실행 결과를 실제로 관리하는 영역이다.
- 실행 컨텍스트는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로 모든 코드는 이를 통해 실행되고 관리된다. (like turing machine..?)
  - **식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리**하고, **실행 순서는 실행 컨텍스트 스택으로 관리**한다.

## 23.4 실행 컨텍스트 스택

```js
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}
foo(); // 6
```

- 전역 코드를 평가해서 전역 실행 컨텍스트부터 만들다가 함수를 만나면 함수 실행 컨텍스트를 생성해서 그 위에 쌓고, 이 코드가 모두 실행되면 다시 전역 실행 컨텍스트로 돌아가는 스택 흐름을 가진다.

1. 전역 코드의 평가와 실행
2. foo 함수 코드의 평가와 실행
3. bar 함수 코드의 평가와 실행
4. foo 함수 코드로 복귀
5. 전역 코드로 복귀

- 실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.
- 실행 컨텍스트 스택 최상위 컨텍스트는 항상 현재 실행 중인 코드이다.
  - 이는 running execution context이다.

## 23.5 렉시컬 환경

- 렉시컬 환경은 식별자와 식별자에 바인딩 된 값, 상위 스코프에 대한 참조를 기록하는 자료구조이다.
- 키와 값을 갖는 객체 형태의 전역, 함수 또는 블록 스코프를 생성한다.
- 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
- 렉시컬 환경은 식별자 등록, 관리 역할을 하는 렉시컬 스코프의 실체이다.

![[{68955E97-1AE7-461D-B0ED-E226EFE09697}.png]]

- 실행 컨텍스트를 구성하는 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트는 생성 초기 동일한 렉시컬 환경을 참조한다.

  - 이후 몇 가지 상황을 만나면 VariableEnvironment를 위한 새로운 렉시컬 환경이 생성될 수 있다.

- 렉시컬 환경은 EnvironmentRecord, OuterLexicalEnvironmentReference 두 개의 컴포넌트로 구성된다.

1. 환경 레코드(EnvironmentRecord) : 스코프에 포함된 식별자 등록, 식별자에 바인딩된 값을 관리하는 저장소.
2. 외부 렉시컬 환경에 대한 참조(OuterLexicalEnvironmentReference) : 상위 스코프를 가리키는 참조이다. 이를 통해 스코프 체인(단방향 linked-list)을 구현한다.

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}
foo(20); // 42
```

### 23.6.1 전역 객체 생성

- 전역 객체(21.4 절)는 전역 코드 평가 이전에 생성되며, 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체가 추가된다.
  - 동작 환경에 따라 Web API 또는 특정 환경을 위한 호스트 객체가 포함된다.
  - 전역 객체도 Object.prototype을 상속받고, 프로토타입 체인의 일원이다.

### 23.6.2 전역 코드 평가

- 소스코드가 로드되면 전역 코드를 평가한다.

1. 전역 실행 컨텍스트 생성 : 전역 실행 컨텍스트 생성 후 스택에 push
2. 전역 렉시컬 환경 생성 : 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩
   2.1 전역 환경 레코드 생성
   2.1.1 객체 환경 레코드 생성
   2.1.2 선언적 환경 레코드 생성
   2.2 this 바인딩
   2.3 외부 렉시컬 환경에 대한 참조 결정

##### 2.1 전역 환경 레코드 생성

- 모든 전역 변수가 전역 객체의 프로퍼티가 되는 ES6 이전에는 전역 객체가 전역 환경 레코드의 역할을 수행했다.
- 그러나 ES6의 let, const 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적 블록 내에 존재한다.
  - 이를 구분해서 관리하기 위해 전역 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다.
- 객체 환경 레코드는 기존 전역 객체가 관리하던 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수, 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 관리한다.
- 선언적 환경 레코드는 let, const로 선언한 전역 변수르 관리한다.

###### 2.1.1 객체 환경 레코드 생성

- 전역 코드 평가 과정에서 var 전역 변수와 전역 함수는 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.
- 이를 통해 전역 객체를 가리키는 window 식별자 없이 alert, console 등을 쓸 수 있다.

```js
var x = 1;
const y = 2;

function foo(a) {}
```

- x 는 var 키워드로 선언한 변수이므로, 선언 단계와 초기화 단계가 동시 진행된다.
  - 전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록한 다음, 암묵적으로 undefined를 바인딩한다.
  - 따라서 var 선언 변수는 코드 실행 단계에서 변수 선언문 이전에도 참조할 수 있다. **(코드 평가 단계에서 undefined로 등록되기 때문이다.)**
- 함수 선언문으로 정의된 함수가 평가되면 함수 이름과 동일한 이름의 식별자로 전역 객체에 키로 등록한 다음, 생성된 함수 객체를 즉시 할당한다.
  - 따라서 코드 평가 단계에서 함수 객체를 생성 및 할당하므로 코드 실행 단계에서 함수 선언문 이전에 호출이 가능한 호이스팅이 발생한다.

###### 2.1.2 선언적 환경 레코드 생성

- 전역 변수 y는 let, const로 선언한 변수이므로 전역 객체에 등록되지 않는다.
- const로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.
- 따라서 초기화 단계, 런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 **일시적 사각지대(Temporal Dead Zone; TDZ)** 에 빠지게 된다.
  - let, const 키워드로 선언한 변수도 변수 호이스팅이 발생하지만 선언만 미리 하고 초기화 단계가 진행되지 않아 변수에 접근할 수 없어서 런타임 이전에 참조할 수 없다.
  - 만약 호이스팅이 발생하지 않는다면 해당 이름과 같은 전역 변수를 참조하려 해야 한다. 그러나 호이스팅이 발생해서 ReferenceError가 뜬다.

##### 2.2 this 바인딩

- 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 this가 바인딩된다. 일반적으로 전역코드에서 this는 전역 객체를 가리킨다.
- 전역 환경 레코드를 구성하는 객체 환경 레코드와 선언전 환경 레코드에는 this 바인딩이 없고, this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재한다.

##### 2.3 외부 렉시컬 환경에 대한 참조 결정

- 외부 렉시컬 환경이 존재한다면 스코프 체인을 만들기 위해 참조를 넣어둔다.

### 23.6.3 전역 코드 실행

- 전역 코드가 실행되고, 전역 변수 x, y에 값이 할당되며 foo 함수가 호출된다.
- 식별자 결정 : 어느 스코프의 식별자를 참조하면 되는지 검색해서 결정하는 것
  - 식별자를 검색할 때는 현재 실행 중인 컨텍스트에서 검색하기 시작한다.
  - 현재 컨텍스트에서 검색할 수 없으면 한 단계 상위 스코프로 이동해서 검색한다.
  - 전역 렉시컬 환경은 종점이므로 여기서 검색할 수 없는 식별자는 ReferenceError가 발생한다.

### 23.6.4 foo 함수 코드 평가

- foo 함수가 호출되면 전역 코드 실행을 중단하고 foo 함수 코드를 평가한다.

1. 함수 실행 컨텍스트 생성 : 함수 실행 컨텍스트 생성 후 실행 컨텍스트 스택에 push
2. 함수 렉시컬 환경 생성 : 함수 렉시컬 환경 생성 후 실행 컨텍스트에 바인딩
   2.1 함수 환경 레코드 생성 : 매개변수, arguments 객체, 지역 변수, 중첩 함수 등록 및 관리
   2.2 this 바인딩 : 함수 환경 레코드 `[[ThisValue]]` 내부 슬롯에 this 바인딩
   2.3 외부 렉시컬 환경에 대한 참조 결정 : 함수 정의가 평가된 시점에 실행 중이던 컨텍스트의 렉시컬 환경 참조가 할당 / 이 경우에서는 전역 렉시컬 환경 참조가 할당

- JS는 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다.
- 함수의 상위 스코프를 함수 객체의 내부 슬롯 `[[Environment]]`에 저장한다.

### 23.6.5 foo 함수 코드 실행

- foo 함수 소스코드가 실행된다.
- 이때 식별자 결정을 위해 foo 함수 실행 컨텍스트의 렉시컬 환경에서 식별자 x, y를 검색한다.
  - 찾았으면 값을 바인딩한다.

### 23.6.6 bar 함수 코드 평가

![[{E284A751-1F18-48B8-B5D3-A370D17FE18F}.png]]

### 23.6.7 bar 함수 코드 실행

![[{380A3982-3D80-450E-9112-8E566DD19FA2}.png]]

- `console.log(a + b + x + y + z);` 실행 순서`

1. console 식별자 검색 : 전역 렉시컬 환경까지 이동 후 검색한다.
2. log 메서드 검색 : console 객체의 프로토타입 체인을 통해 검색한다.
3. 표현식 a + b + x + y + z의 평가 : 각 식별자가 선언된 렉시컬 환경에서 검색 후 값을 읽어온다.
4. console.log 메서드 호출

### 23.6.8 bar 함수 코드 실행 종료

- 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 pop 되어 제거된다.
- 단, bar 함수 실행 컨텍스트가 제거되어도 bar 함수 렉시컬 환경이 즉시 소멸되는 것은 아니다.
  - 렉시컬 환경은 실행 컨텍스트에 의해 참조는 되나 독립적인 객체다.
  - 객체를 포함한 모든 값은 아무 누구에게도 참조되지 않을 때 가비지 컬렉터에 의해 메모리 공간이 회수되어 소멸한다.
- 따라서 bar 함수 렉시컬 환경을 다른 누군가 참조 중이라면 소멸되지 않는다.

### 23.6.9 foo 함수 코드 실행 종료

- foo 함수 실행 컨텍스트도 pop 되어 제거된다.

### 23.6.10 전역 코드 실행 종료

- 전역 코드도 없으므로 전역 실행 컨텍스트도 pop되어 실행 컨텍스트 스택은 비어있게 된다.

## 23.7 실행 컨텍스트와 블록 레벨 스코프

```js
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}
console.log(x); // 1
```

- var 변수는 오로지 함수와 코드 블록만 지역 스코프로 인정하는 함수 레벨 스코프를 따른다.
- 그러나 let, const는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

  - if 문의 코드 블록이 실행되면 if 문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다.
  - 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새로 생성하여 기존 전역 렉시컬 환경을 교체한다.
  - 이때 새로 생성된 if 문 코드 블럭을 위한 렉시컬 환경의 외부 렉시컬 환경 참조는 if 문 실행 이전 전역 렉시컬 환경을 가리킨다.

- for문의 변수 선언문에 let 키워드를 사용했다면, for문은 코드 블록이 반복해서 실행할 때마다 코드 블록을 위한 새로운 렉시컬 환경을 생성한다.
- 이때 함수의 상위 스코프는 for 문의 코드 블록이 반복 실행될 때마다 값을 유지해야 하므로 독립적인 렉시컬 환경을 생성하는 것이다.
